顶层 const 是指变量的值不可以改变，底层 const 是值指针/引用指向的值不可变

顶层 const 影响的是变量本身，底层 const 影响的指针所指的值
如 在函数声明时
```cpp
int f(const int x); // 仅表示在函数运行时形参 x 的值不改变，实参与形参是通过拷贝构造函数复制过来的，不影响实参的值，所以复制时，可以忽略 顶层 const
```
而底层 const 会影响实参的值，所有常量能接收非常量，非常不能接收常量，这样保证了数据安全，可以理解为，底层 const 是指针操作的数据的一个属性

声明为const 的引用含有底层 const 属性

> 所有具有顶层 const 的常量都需要初始化，如 const int, int* const, int &
> 综上，复制时(比如 =， 函数传递传递)，忽略顶层 const，受底层 const 限制
> const type & 如果是相同类型的变量则左值就是该变量，如果是其他类型，或者是表达式，则左值是一个过程量(或者说是右值引用)
> && 为右值引用，初始化的量一定是一个过程量，或者表达式
> & 为左值引用，普通的左值引用必须是相同类型的左值(可以是顶层 const 兼容)

const 是在运行时初始化， constexpr 是在编译时初始化，也就是表达式的值都要在编译时知道，均为常量

---

auto 会忽略顶层 const 和引用类型和引用的底层const, 声明引用可以写成 auto&，但是不会指针的忽略底层 const
**不是引用的auto定义只保留类型名(指针)，和指针的底层 const**
**而引用的auto定义保留左值的顶层const，即引用变量有底层const属性**
> auto&x = 4.3 错误，因为 auto& 判断出来的是 double&， 是左值引用，需要改为 const auto&x = 4.3
> 一条 auto 语句可以定义多个变量，但每个变量的类型都要相同
> auto x = 3, y = 12, z = 30;  	//正确，x,y,z为int类型
> auto a = 3, b = 3.2;          //错误，a和b的类型不同
> 可以理解为 auto 在预处理时，编译器会把auto 替换成推断出来的类型进行编译

decltype(x) 推断完全保留x的类型，包括指针，引用，顶层const、底层const等
> int *p = &i;
> decltype(*p) y2 = a; // int &y2 = a; !!!!!!
